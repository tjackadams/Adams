@page "/smoker/{Name}/edit"
@attribute [Authorize]

@inject IHttpClientFactory HttpFactory
@inject NavigationManager Router
@inject ILogger<Edit> Logger

@if (!string.IsNullOrWhiteSpace(Message))
{
    <BSAlert Color="Color.Danger">
        @Message
    </BSAlert>}

<SpinLoader IsLoading="@(Data == null)">
    <ContentTemplate>
        <BSForm Model="Data" OnValidSubmit="HandleValidSubmit">

            <FluentValidationValidator/>
            <PortalValidator @ref="_portalValidator"/>
            <ValidationSummary/>
            <BSRow>
                <BSCol MD="6">

                    <h4>Recipe</h4>

                    <BSFormGroup>
                        <BSLabel For="@Data.Name">Name</BSLabel>
                        <BSInput Id="@Data.Name" InputType="InputType.Text" @bind-Value="Data.Name" IsReadonly="true"></BSInput>
                    </BSFormGroup>

                    <BSFormGroup>
                        <BSLabel For="@Data.DisplayName">Display name</BSLabel>
                        <BSInput Id="@Data.DisplayName" InputType="InputType.Text" @bind-Value="Data.DisplayName"/>
                    </BSFormGroup>

                    <BSFormGroup>
                        <BSLabel For="@Data.Description">Description</BSLabel>
                        <BSInput Id="@Data.Description" InputType="InputType.TextArea" @bind-Value="Data.Description"/>
                    </BSFormGroup>

                    <BSButton Color="Color.Secondary" ButtonType="ButtonType.Button" @onclick="@(() => Router.NavigateTo("/smoker"))">Cancel</BSButton>
                    <BSButton Color="Color.Primary" ButtonType="ButtonType.Submit">Save</BSButton>

                </BSCol>
                <BSCol MD="6">
                    <BSContainer>

                        <h4>Steps</h4>

                        <BSRow>
                            <BSCol Class="col-12">
                                <div class="d-flex">
                                    <BSFormGroup Class="flex-fill mb-2 mr-sm-2 mb-sm-0">
                                        <BSBasicInput InputType="InputType.TextArea" PlaceHolder="New step..." @bind-Value="NewStepDescription"/>
                                    </BSFormGroup>
                                    <BSButton ButtonType="ButtonType.Button" @onclick="HandleNewStep">
                                        Add
                                    </BSButton>
                                </div>
                            </BSCol>
                        </BSRow>

                        <Plk.Blazor.DragDrop.Dropzone Items="Data.Steps" Context="step" AllowsDrag="(d) => !d.IsReadOnly" OnItemDrop="@(i => { LastDropped = i; SortSteps(); })" TItem="Command.CommandStep">
                            <BSRow>
                                <BSCol MD="12">
                                    <RecipeStep OnRemoveClick="HandleDeleteStep" Step="step"/>
                                </BSCol>
                            </BSRow>
                        </Plk.Blazor.DragDrop.Dropzone>
                    </BSContainer>
                </BSCol>
            </BSRow>
        </BSForm>
    </ContentTemplate>
</SpinLoader>

@code {

    private void HandleDeleteStep(Command.CommandStep step)
    {
        Data.Steps.Remove(step);
        SortSteps();
    }

    private void HandleNewStep()
    {
    // insert the new item before the finish.
        var finishIndex = Data.Steps.FindIndex(s => s.Step == Data.Steps.Max(x => x.Step));

        Logger.LogInformation("index: {index}", finishIndex);

        Data.Steps.Insert(finishIndex, new Command.CommandStep
        {
            Description = NewStepDescription
        });

    // reset to a clean state
        NewStepDescription = string.Empty;

        SortSteps();
    }

    private void SortSteps()
    {
    // start should always be top of the list
        var startIndex = Data.Steps.FindIndex(s => s.Description == "Start");
        if (startIndex != 0)
        {
            var start = Data.Steps.ElementAt(startIndex);
            Data.Steps.RemoveAt(startIndex);

            Data.Steps.Insert(0, start);
        }

    // finish should always be at the end of the list
        var finishIndex = Data.Steps.FindIndex(s => s.Description == "Finish");
        if (finishIndex != Data.Steps.Count - 1)
        {
            var finish = Data.Steps.ElementAt(finishIndex);
            Data.Steps.RemoveAt(finishIndex);
            Data.Steps.Insert(Data.Steps.Count, finish);
        }

        Data.Steps = Data.Steps.Select((s, i) =>
        {
            s.Step = i + 1;
            return s;
        }).ToList();

        StateHasChanged();
    }

    private string NewStepDescription { get; set; }

    private Command.CommandStep LastDropped { get; set; }

    [Parameter]
    public string Name { get; set; }

    private string Message { get; set; }

    private Command Data { get; set; }

    private PortalValidator _portalValidator;

    public class Command
    {
        public string Name { get; set; }
        public string DisplayName { get; set; }
        public string Description { get; set; }
        public List<CommandStep> Steps { get; set; }

        public class CommandStep
        {
            public int Id { get; set; }
            public int Step { get; set; }
            public string Description { get; set; }

            public bool IsReadOnly
            {
                get
                {
                    if (Description == "Start" || Description == "Finish")
                    {
                        return true;
                    }

                    return false;
                }
            }
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        var http = HttpFactory.CreateClient(HttpClients.SmokingClient);
        Data = await http.GetFromJsonAsync<Command>($"recipes/{Name}/edit");
        if (Data == null)
        {
            Router.NavigateTo("/smoker");
            return;
        }


        Data.Steps = Data.Steps.OrderBy(s => s.Step).ToList();
    }

    private async Task HandleValidSubmit(EditContext editContext)
    {
        _portalValidator.ClearErrors();

        try
        {
            var http = HttpFactory.CreateClient(HttpClients.SmokingClient);

            var response = await http.PostAsJsonAsync($"recipes/{Name}/edit", (Command) editContext.Model);
            if (response.StatusCode == HttpStatusCode.OK)
            {
                Router.NavigateTo($"/smoker/{Name}/details");
            }
            else if (response.StatusCode == HttpStatusCode.BadRequest)
            {
                var errors = (await response.Content.ReadFromJsonAsync<BadRequestResponse>(new JsonSerializerOptions {PropertyNamingPolicy = JsonNamingPolicy.CamelCase}))?.Errors;

                _portalValidator.DisplayErrors(errors);
            }
            else
            {
                response.EnsureSuccessStatusCode();
            }
        }
        catch (AccessTokenNotAvailableException ex)
        {
            ex.Redirect();
        }
        catch (Exception ex)
        {
            Logger.LogError("Form processing error: {Message}", ex.Message);
            Message = "There was an error processing the form.";
        }
    }

    public class Validator : AbstractValidator<Command>
    {
        public Validator()
        {
            RuleFor(p => p.DisplayName)
                .NotEmpty()
                .MaximumLength(200);

            RuleFor(p => p.Description)
                .NotEmpty()
                .MaximumLength(2000);
        }
    }

}